import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'
import type { AppState, AppThunk } from '../../store'
import { fetchCount } from './counterAPI'

// 计数器的状态接口
export interface CounterState {
  value: number
  status: 'idle' | 'loading' | 'failed'
}


// 切片的初始状态
const initialState: CounterState = {
  value: 0,
  status: 'idle',
}


// 下面的函数被称为thunk，它允许我们执行异步逻辑。它可以像常规操作一样进行调度：“dispatch（incrementAsync（10））”。
// 这将调用以“dispatch”函数作为第一个参数的thunk。然后可以执行异步代码，并可以调度其他操作。Thunk通常用于发出异步请求。

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount: number) => {
    const response = await fetchCount(amount)
    // The value we return becomes the `fulfilled` action payload
    return response.data
  }
)

// Creating a slice requires a string name to identify the slice, an initial state value, and one or more reducer functions to define how the state can be updated. Once a slice is created, we can export the generated Redux action creators and the reducer function for the whole slice.
// Redux requires that we write all state updates immutably, by making copies of data and updating the copies. However, Redux Toolkit's createSlice and createReducer APIs use Immer inside to allow us to write "mutating" update logic that becomes correct immutable updates.

// 创建切片需要一个字符串名称来标识切片，一个初始 state，以及一个或多个 reducer 函数来定义如何更新状态。一旦创建了一个切片，我们就可以导出生成的Redux动作创建者和整个切片的reducer函数。
// Redux要求我们通过制作数据副本和更新副本来免疫地编写所有状态更新。然而，Redux Toolkit 的 createSlice 和 createReducer API 在内部使用Immer，允许我们编写“可变”更新逻辑，使其成为正确的不可变更新。

export const counterSlice = createSlice({
  // 名称 counter
  name: 'counter',
  // 初始 state
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: (state) => {
      state.value -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // “extraReducers”字段允许切片处理其他地方定义的操作，包括 createAsyncThunk 或其他切片中生成的操作。
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.value += action.payload
      })
  },
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

// 下面的函数被称为选择器，它允许我们从状态中选择一个值。选择器也可以在使用它们的地方内联定义，而不是在切片文件中。
// 例如：`useSelector（（state:RootState）=>state.counter.value）`

export const selectCount = (state: AppState) => state.counter.value

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd =
  (amount: number): AppThunk =>
  (dispatch, getState) => {
    const currentValue = selectCount(getState())
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount))
    }
  }

export default counterSlice.reducer
